<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ ta.name }} - Maize</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/style.css?v=12">
    <link rel="stylesheet" href="/static/css/chat-brand.css?v=12">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
</head>
<body class="chat-page">
    <div class="chat-container">
        <header class="chat-header">
            <div class="header-info">
                <h1>{{ ta.name }}</h1>
                <p class="course-name">{{ ta.course_name }}</p>
            </div>
            <a href="/" class="logo-link">
                <img src="/static/images/maize-logo.png" alt="Maize" class="logo-img">
                <span class="logo-text">Maize</span>
            </a>
        </header>
        
        <main class="chat-main">
            <div id="messages" class="messages">
                <div class="message assistant" id="welcome-message">
                    <img src="/static/images/maize-logo.png" alt="Maize" class="ta-avatar">
                    <div class="message-content">
                        <p>Hello! I'm your teaching assistant for <strong>{{ ta.course_name }}</strong>. I'm here to help you understand course concepts, work through problems, and prepare for exams.</p>
                        <p>How can I help you today?</p>
                    </div>
                </div>
            </div>
        </main>
        
        <footer class="chat-footer">
            <form id="chat-form" onsubmit="sendMessage(event)">
                <div class="input-group">
                    <button type="button" id="clear-btn" class="btn-clear" onclick="clearHistory()" title="Start new conversation">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                            <path d="M3 3v5h5"/>
                        </svg>
                    </button>
                    <textarea 
                        id="query-input" 
                        placeholder="Ask a question about the course..." 
                        rows="1"
                        onkeydown="handleKeydown(event)"
                    ></textarea>
                    <button type="submit" id="send-btn" class="btn btn-primary">Send</button>
                </div>
            </form>
            <p class="disclaimer">This TA helps explain concepts but won't give direct homework answers.</p>
        </footer>
    </div>
    
    <script>
        let sessionId = '';
        const taSlug = '{{ ta.slug }}';
        
        const statusMessages = [
            'Searching course materials...',
            'Analyzing relevant content...',
            'Generating response...'
        ];
        
        function handleKeydown(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage(e);
            }
        }
        
        function generateSessionId() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        
        function clearHistory() {
            const messagesEl = document.getElementById('messages');
            messagesEl.innerHTML = `
                <div class="message assistant">
                    <img src="/static/images/maize-logo.png" alt="Maize" class="ta-avatar">
                    <div class="message-content">
                        <p>Hello! I'm your teaching assistant for <strong>{{ ta.course_name }}</strong>. I'm here to help you understand course concepts, work through problems, and prepare for exams.</p>
                        <p>How can I help you today?</p>
                    </div>
                </div>
            `;
            
            sessionId = generateSessionId();
            
            const input = document.getElementById('query-input');
            input.value = '';
            input.focus();
        }
        
        function autoResize(el) {
            el.style.height = 'auto';
            el.style.height = Math.min(el.scrollHeight, 150) + 'px';
        }
        
        document.getElementById('query-input').addEventListener('input', function() {
            autoResize(this);
        });
        
        function addMessage(role, content, sources = []) {
            const messagesEl = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;
            
            let html = `<div class="message-content">${formatContent(content)}</div>`;
            
            if (sources && sources.length > 0) {
                const uniqueSources = [...new Set(sources)];
                html += `
                    <div class="message-sources">
                        <span class="sources-label">Sources:</span>
                        ${uniqueSources.map(s => `<span class="source-tag">${s}</span>`).join('')}
                    </div>
                `;
            }
            
            messageDiv.innerHTML = html;
            messagesEl.appendChild(messageDiv);
            messagesEl.scrollTop = messagesEl.scrollHeight;
            renderLatex(messageDiv);
        }
        
        function preprocessLatex(text) {
            let processed = text;
            
            processed = processed.replace(/\\\[([\s\S]*?)\\\]/g, '$$$$$1$$$$');
            processed = processed.replace(/\\\(([\s\S]*?)\\\)/g, '$$$1$$');
            
            return processed;
        }
        
        function sanitizeForRendering(text) {
            // Fix common LLM formatting issues that break rendering
            let sanitized = text;
            
            // 1. Remove asterisks that are adjacent to $ (math delimiters)
            //    e.g., "*$x$*" -> "$x$", "**$equation$**" -> "$equation$"
            sanitized = sanitized.replace(/\*+(\$[^\$]+\$)\*+/g, '$1');
            sanitized = sanitized.replace(/\*+(\$\$[\s\S]*?\$\$)\*+/g, '$1');
            
            // 2. Remove asterisks before LaTeX commands (e.g., "**\varepsilon" -> "\varepsilon")
            //    Must capture full command name (varepsilon, frac, cdot, etc.)
            sanitized = sanitized.replace(/\*+(\\[a-zA-Z]+)/g, '$1');
            sanitized = sanitized.replace(/(\\[a-zA-Z]+)\*+/g, '$1');
            
            // 3. Remove trailing asterisks at end of sentences/lines
            sanitized = sanitized.replace(/\s\*+\s*$/gm, '');
            sanitized = sanitized.replace(/\.\s*\*+\s/g, '. ');
            sanitized = sanitized.replace(/\.\s*\*+$/gm, '.');
            
            // 4. Remove asterisks around section headers like "*2b) Title:**" or "**2a) Title:**"
            sanitized = sanitized.replace(/^\*+\s*(\d+[a-zA-Z]?\))/gm, '$1');
            sanitized = sanitized.replace(/\*+\s*(\d+[a-zA-Z]?\))/g, '$1');
            sanitized = sanitized.replace(/:\s*\*+\s*$/gm, ':');
            sanitized = sanitized.replace(/:\s*\*+\s*\n/g, ':\n');
            
            // 5. Fix unbalanced $ signs by escaping lone $ that aren't part of pairs
            const dollarMatches = sanitized.match(/\$/g);
            if (dollarMatches && dollarMatches.length % 2 === 1) {
                sanitized = sanitized.replace(/\$(?=\d+[,.]?\d*(?:[^$]|$))/g, '\\$');
            }
            
            // 6. Fix asterisks inside what looks like math content
            sanitized = sanitized.replace(/(\w)\*(\w+)\*(\w)/g, '$1\\*$2\\*$3');
            
            // 7. Clean up long broken bold patterns
            sanitized = sanitized.replace(/\*\*([^\*]{100,})\*\*/g, (match, content) => {
                if (!content.includes(' ')) {
                    return content;
                }
                return match;
            });
            
            // 8. Same for single asterisk italics
            sanitized = sanitized.replace(/\*([^\*]{100,})\*/g, (match, content) => {
                if (!content.includes(' ')) {
                    return content;
                }
                return match;
            });
            
            // 9. Remove any remaining lone asterisks that aren't valid markdown
            //    Simple approach: remove * surrounded by spaces or at line boundaries
            sanitized = sanitized.replace(/\s\*\s/g, ' ');
            sanitized = sanitized.replace(/^\*\s/gm, '');
            sanitized = sanitized.replace(/\s\*$/gm, '');
            
            // 10. Strip all asterisks if content has math (aggressive cleanup for math-heavy responses)
            if (sanitized.includes('$') || sanitized.includes('\\frac') || sanitized.includes('\\varepsilon')) {
                // Remove bold/italic markers entirely - they just cause problems with math
                // First remove bold (**text**)
                sanitized = sanitized.replace(/\*\*([^*]+)\*\*/g, '$1');
                // Then remove italic (*text*) - Safari-compatible without lookbehind
                // Match *text* where text doesn't start/end with * and has no newlines
                sanitized = sanitized.replace(/\*([^*\n]+)\*/g, '$1');
            }
            
            return sanitized;
        }
        
        function formatContent(content) {
            // First sanitize problematic patterns
            content = sanitizeForRendering(content);
            content = preprocessLatex(content);
            
            const mathPlaceholders = [];
            let placeholderIndex = 0;
            
            // Protect display math first ($$...$$)
            content = content.replace(/\$\$([\s\S]*?)\$\$/g, (match) => {
                mathPlaceholders.push(match);
                return `%%%MATH_DISPLAY_${placeholderIndex++}%%%`;
            });
            
            // Protect inline math ($...$) - improved regex to be more robust
            // Only match if there's content between $ signs and no newlines
            content = content.replace(/\$([^\$\n]+?)\$/g, (match, inner) => {
                // Skip if the inner content looks like it's not math (e.g., currency)
                if (/^\d+[,.]?\d*$/.test(inner.trim())) {
                    return match; // Leave currency-like patterns alone
                }
                mathPlaceholders.push(match);
                return `%%%MATH_INLINE_${placeholderIndex++}%%%`;
            });
            
            // Apply markdown formatting
            content = content.replace(/\n/g, '<br>');
            
            // Bold - only match if content is reasonable length and has spaces
            content = content.replace(/\*\*(.{1,80}?)\*\*/g, '<strong>$1</strong>');
            
            // Italic - only match if content is reasonable length
            // Safari-compatible: match *text* but only if not inside ** markers
            // We already handled ** for bold above, so remaining single * pairs are italic
            content = content.replace(/\*([^\*\n]{1,80}?)\*/g, '<em>$1</em>');
            
            // Code
            content = content.replace(/`([^`]+)`/g, '<code>$1</code>');
            
            // Restore math placeholders
            for (let i = 0; i < mathPlaceholders.length; i++) {
                content = content.replace(`%%%MATH_DISPLAY_${i}%%%`, mathPlaceholders[i]);
                content = content.replace(`%%%MATH_INLINE_${i}%%%`, mathPlaceholders[i]);
            }
            
            return `<p>${content}</p>`;
        }
        
        function renderLatex(element) {
            if (typeof renderMathInElement !== 'undefined') {
                try {
                    renderMathInElement(element, {
                        delimiters: [
                            {left: '$$', right: '$$', display: true},
                            {left: '$', right: '$', display: false},
                            {left: '\\[', right: '\\]', display: true},
                            {left: '\\(', right: '\\)', display: false}
                        ],
                        throwOnError: false,
                        errorColor: '#cc0000',
                        strict: false,
                        trust: true,
                        macros: {
                            "\\R": "\\mathbb{R}",
                            "\\N": "\\mathbb{N}",
                            "\\Z": "\\mathbb{Z}",
                            "\\Q": "\\mathbb{Q}",
                            "\\C": "\\mathbb{C}"
                        },
                        // Custom error handler - show clean fallback instead of ugly error
                        errorCallback: function(msg, err) {
                            console.warn('KaTeX error:', msg, err);
                        }
                    });
                    
                    // Post-process: find any KaTeX error spans and clean them up
                    const errorSpans = element.querySelectorAll('.katex-error');
                    errorSpans.forEach(span => {
                        // Extract the original text and display it cleanly
                        const originalText = span.getAttribute('title') || span.textContent;
                        // Remove the $ delimiters for cleaner display
                        const cleanText = originalText.replace(/^\$+|\$+$/g, '');
                        span.className = 'math-fallback';
                        span.style.cssText = 'font-family: "Times New Roman", serif; font-style: italic; color: inherit;';
                        span.textContent = cleanText;
                    });
                } catch (e) {
                    console.warn('LaTeX rendering error:', e);
                }
            }
        }
        
        function addStreamingMessage() {
            const messagesEl = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message assistant streaming';
            messageDiv.id = 'streaming-message';
            messageDiv.innerHTML = `
                <img src="/static/images/maize-logo.png" alt="Maize" class="ta-avatar">
                <div class="message-wrapper">
                    <div class="message-status">
                        <div class="status-indicator">
                            <span class="status-dot"></span>
                            <span class="status-text">Preparing...</span>
                        </div>
                    </div>
                    <div class="message-content" id="streaming-content"></div>
                </div>
            `;
            messagesEl.appendChild(messageDiv);
            messagesEl.scrollTop = messagesEl.scrollHeight;
            return messageDiv;
        }
        
        function updateStreamingStatus(message) {
            const statusText = document.querySelector('#streaming-message .status-text');
            if (statusText) {
                statusText.textContent = message;
            }
        }
        
        function hideStreamingStatus() {
            const statusDiv = document.querySelector('#streaming-message .message-status');
            if (statusDiv) {
                statusDiv.style.display = 'none';
            }
        }
        
        function appendToStreamingContent(token) {
            const contentEl = document.getElementById('streaming-content');
            if (contentEl) {
                contentEl.textContent += token;
                const messagesEl = document.getElementById('messages');
                messagesEl.scrollTop = messagesEl.scrollHeight;
            }
        }
        
        function finalizeStreamingMessage(sources) {
            const streamingMsg = document.getElementById('streaming-message');
            if (!streamingMsg) return;
            
            const contentEl = document.getElementById('streaming-content');
            const rawContent = contentEl.textContent;
            
            streamingMsg.id = '';
            streamingMsg.className = 'message assistant';
            
            let html = `<img src="/static/images/maize-logo.png" alt="Maize" class="ta-avatar">`;
            html += `<div class="message-content">${formatContent(rawContent)}`;
            
            if (sources && sources.length > 0) {
                const uniqueSources = [...new Set(sources)];
                html += `
                    <div class="message-sources">
                        <span class="sources-label">Sources:</span>
                        ${uniqueSources.map(s => `<span class="source-tag">${s}</span>`).join('')}
                    </div>
                `;
            }
            
            html += `</div>`;
            streamingMsg.innerHTML = html;
            renderLatex(streamingMsg);
        }
        
        async function sendMessage(e) {
            e.preventDefault();
            
            const input = document.getElementById('query-input');
            const query = input.value.trim();
            
            if (!query) return;
            
            addMessage('user', query);
            input.value = '';
            autoResize(input);
            
            const sendBtn = document.getElementById('send-btn');
            sendBtn.disabled = true;
            
            let sources = [];
            addStreamingMessage();
            
            try {
                const response = await fetch(`/${taSlug}/api/chat/stream`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ query, session_id: sessionId })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Request failed');
                }
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let hasStartedContent = false;
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    buffer += decoder.decode(value, { stream: true });
                    
                    const events = buffer.split('\n\n');
                    buffer = events.pop() || '';
                    
                    for (const event of events) {
                        const lines = event.split('\n');
                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                try {
                                    const data = JSON.parse(line.slice(6));
                                    
                                    switch (data.type) {
                                        case 'status':
                                            updateStreamingStatus(data.message);
                                            break;
                                        case 'sources':
                                            sources = data.sources;
                                            break;
                                        case 'token':
                                            if (!hasStartedContent) {
                                                hideStreamingStatus();
                                                hasStartedContent = true;
                                            }
                                            appendToStreamingContent(data.content);
                                            break;
                                        case 'done':
                                            sessionId = data.session_id;
                                            finalizeStreamingMessage(sources);
                                            break;
                                        case 'error':
                                            throw new Error(data.message);
                                    }
                                } catch (parseErr) {
                                    if (parseErr.message !== 'Unexpected end of JSON input') {
                                        console.warn('Parse error:', parseErr);
                                    }
                                }
                            }
                        }
                    }
                }
                
            } catch (err) {
                console.error('Stream error:', err);
                const streamingMsg = document.getElementById('streaming-message');
                if (streamingMsg) {
                    streamingMsg.remove();
                }
                addMessage('assistant', `I apologize, but I had trouble processing your request: ${err.message}`);
            } finally {
                sendBtn.disabled = false;
                input.focus();
            }
        }
    </script>
</body>
</html>
